https://doc.rust-lang.org/book/ch01-01-installation.html

https://doc.rust-lang.org/book/ch01-02-hello-world.html

https://doc.rust-lang.org/book/ch01-03-hello-cargo.html
  Cargo - the build system and package manager
    It does multiple things:
      - building your code
      - downloading the libraries (dependencies)
      - checks code
      - runs the code

    create and run a new project
      $ cargo new <project_name>
        source files will live inside the <project_name>/src
      $ cd <project_name>
        cd into the project directory to run additional cargo commands
      $ cargo build
        creates build directory target/debug
        then compiles binary and places it in ./target/debug/<project_name>
      $ cargo build --release
        compile it with optimizations (faster execution)
        NOTE: creates an executable in target/release instead of target/debug
      $ cargo run
        same as cargo build, but also runs the binary if compile succeeded
        ..most developers use cargo run
      $ cargo check
        build a project without producing a binary to check for errors

    Crates
      packages of code are referred to as crates

    Cargo.lock
      Keeps track of the exact versions of dependencies in your project.
      We do not ever need to change this file manually.
      Cargo manages its contents for you.

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html
  $ cargo new guessing_game
  $ cd guessing_game

  Importing and "Prelude".
    Manually importing every single thing that you use is very verbose.
    Automatically importing a lot of things that a program never uses is bloat.
    A balance needs to be struck and that is the Prelude.
    The prelude is the list of things that Rust automatically imports into every Rust program.

    The use statement.
      Importing is don with "use".

  Importing standard io library (bringing the library into scope)
    > use std::io;
      this is used read input and writing output etc.

  Variables.
    > let mut <name> = <value>;

    immutable
      > let apples = 5;
    mutable
      > let mut bananas = 5;

  Types
    String: growable UTF-8 encoded bit of text

  Syntax
    :: Is an associated function of a type.
      > String::new();
        new is associated with the String type
        new creates a new, empty string..

    .name() Is a method
      > io::stdin()
      >   .read_line(&mut some_var)
        here the read_line() is a method on stdin()

    & Is a reference
      > .read_line(&mut some_var)
        referencing "some_var" Note: references are immutable

    io::stdin().read_line() returns a "Result" value which is an "enumeration" (enum)
      used to encode error-handling information with variants Ok and Err
      enums are covered in chapter 6..
      the "Result" value has an expect method
      if value is Err -> expect(argument) will cause the program to crash and display the message passed as argument
        most likely it would be OS related in this very case..

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#generating-a-secret-number
  Generate secret number using a "crate"
    ..a crate is a collection of Rust source code files
  
  $ cargo build
  Cargo.lock
    Rust creates the Cargo.lock file the first time you run cargo build.
    This will force the use of same version if new versions of dependency is released.
    This will reproduce builds identical to previous builds on unchanged source code.

  $ cargo update
    Ignore the Cargo.lock file and figure out all the latest versions in Cargo.toml.
    It will still not update to new "major" versions, only "minor" versions.
      see https://semver.org/

  $ cargo doc --open
    Automatically build documentation (HTML) provided for all dependencies
    It will open your default browser when done.
      If you are interested in other functionality in the rand crate,
      run cargo doc --open and click rand in the sidebar on the left.


https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html
  Common Programming Concepts
  
  Rust encourages immutability, and this is the standard for variables unless specified.
    can not change
      > let  x = 5;
    can change
      > let mut x = 5;
    can not change, ever (should always be written in upper case)
      const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
        the result is calculated at compile time so that on execution time it does not have to

  Shadowing (assign new value to immutable variable)
    Rust helps you avoid creating duplicate variables with unique names.
    Creating a new variable with same name as an existing one will "shadow" the old value with new.
    Shadows are scope related, an inner scope does not shadow a variable from an outer scope.
    When shadowing, the variable might also change type, not only value.


https://doc.rust-lang.org/book/ch03-02-data-types.html
  Data Types

  Type anotation
    specify type when declaring variables (sometimes required like in the line below)
    > let guess: u32 = "42".parse().expect("Not a number!");
      it is the value after :, in this case the anotation is "u32"

  Integers (integer types default to i32 if not specified)
    Length    Signed  Unsigned
    8-bit	    i8  	  u8
    16-bit	  i16     u16
    32-bit    i32     u32
    64-bit    i64     u64
    128-bit   i128    u128
    arch      isize   usize
      ..each variant can be either signed (can be negative) or unsigned (only positive)

      ..integer overflow (complement wrapping)
        Variable starts from 0 and adds overflow value.
        https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-overflow

  Floating points
    f32 is a 32 bit value with single-precision
    f64 is a 64 bit value with double precision


https://doc.rust-lang.org/book/ch03-03-how-functions-work.html
  Functions

https://doc.rust-lang.org/book/ch03-05-control-flow.html
  Control flow

https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html
  Ownership - memory handling in Rust

    The Stack and the Heap
      Both are parts of memory, but are structured in different ways.
      Stack (stack based -> fast)
        Stores values in the order it gets them and removes the values in the opposite order.
          ..last in, first out e.g. push -> add and pop -> remove.
      Heap (allocation/pointer based -> slower)
        Is less organized: when you put data on the heap, you request a certain amount of memory space.
        The memory allocator finds an empty spot in the heap that is big enough, mark it as being used.
        It returns a pointer (the memory address of the location).
          ..this is called "allocating on the heap"
      When program calls a function,
        the values passed into the function
        and the functions local variables
        ..get pushed onto the stack.
      When the function is over,
        ..those values get popped off the stack.

  Following the ownership, the goal is to minimize the data stored as heap by..
    ..keep track of what parts of code are using data on the heap
    ..minimize the amount of data (especially duplicate) on the heap
    ..and cleaning up unused data on the heap,

  Ownership rules
    Each value has an owner.
    Only one owner at a time.
    When owner goes out of scope, value is dropped.

  Illustrating the ownership: https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-string-type

https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#references-and-borrowing


https://doc.rust-lang.org/book/ch04-03-slices.html
  The Slice Type
    ..slices let you reference a contiguous sequence of elements in a collection
    ..rather than the whole collection.

  A string slice is a reference to part of a String
    > let s = String::from("hello world");
    > let hello = &s[0..5];
    > let world = &s[6..11];


https://doc.rust-lang.org/book/ch05-00-structs.html
  Structs

  Each struct you define is its own type.
  A function that takes a parameter of type Color cannot take a Point as an argument,
  even though both types are made up of the same primitive datatypes e.g. i32.

  https://doc.rust-lang.org/book/ch05-02-example-structs.html

  https://doc.rust-lang.org/book/ch05-02-example-structs.html#adding-useful-functionality-with-derived-traits

  https://doc.rust-lang.org/book/ch05-03-method-syntax.html

  Declaring structs:
    > struct Rectangle {
    >   width: u32,
    >   height: u32,
    > }

  Implement methods to the struct:
    > impl Rectangle {
    >   fn area(&self) -> u32 {
    >     self.width * self.height
    >   }
    > }

  Instantiate struct:
    > let rect = Rectangle {
    >   width: 30,
    >   height: 50,
    > };

  Call method on struct object:
    > rect.area();


https://doc.rust-lang.org/book/ch06-00-enums.html
  Enums and pattern matching

  ..setting a single value from a set of possible values.
  For example, we may want to say that Rectangle is one of a set of possible shapes.
  The shapes may include Circle and Triangle etc..
  Rust allows encoding these possibilities as an enum.

  Declare enum:
    > enum IpAddr {
    >   V4(u8, u8, u8, u8),
    >   V6(String),
    > }

  Instantiate enum (example for both V4 and V6):
    > let home = IpAddr::V4(127, 0, 0, 1);
    > let loopback = IpAddr::V6(String::from("::1"));
  
  The instance is namespaced under its identifier, in this example it is "IpAddr".
  Notice that we use a double colon to separate the two.

  Define a function that takes the custom enum type:
  > fn route(ip_kind: IpAddr) {....}
  
  Note that we can define a function that takes any IpAddr to handle both cases V4 and V6.

  https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values
    Rust doesn't have the null feature that many other languages have.
    Option is an enum defined by the standard library.
    It encodes a common scenario in which a value could be something or nothing (e.g. null).

    Combining match and enums is useful in many situations.

  https://doc.rust-lang.org/book/ch06-03-if-let.html
    if let - Syntax that lets you assign value if condition is true and then run associated code.


https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
  Managing Growing Projects with Packages, Crates, and Modules

    Keywords:
      mod     -> define a module
      pub     -> make an item public (module, struct, enum, function..)
      super   -> refernece item in parent module (kinda like "cd .." in a unix filesystem)
      use     -> used to shorten the path required to refer to a module item (kinda like symlink in a unix filesystem)
      pub use -> re-export code (now external source code can access the the code in this file)
      as      -> change name of something imported with "use"

    Creating a library with the command:
      $ cargo new my_library_name --lib

    Crate:
      A tree of modules that produces a library or executable.
      Is the smallest piece of code the compiler considers at a time.
      It can be as simple as one file with a main function.
      It can be either a Binary crate or a Library crate.
        Binary crates comiles to a program.
          Crate root is src/main.rs
        Library crates have no main function and does not compile to a program.
          Crate root is src/lib.rs
      Cargo passes the crate root files to rustc to build the library or binary.

    Package:
      A Cargo feature that lets you build, test, and share crates.
      Is a bundle of one or more crates.
      Contains a Cargo.toml file that describes how to build those crates.
      Can have only one library crate.
      Can have multiple binary crates placing files in the src/bin directory (each file as a separate binary crate).
      Must contain at least one crate, whether thats a library or binary crate.
    
    Modules (and use):
      For organization of the scope and privacy of paths in a crate.
      Code within a module is private by default and can be made public.
      To structure a crate, we organize its functions into nested modules.

    Path:
      To show Rust where in the module tree it can find functions, methods, structs etc.
      ..are private to parent modules by default.
      If you want to make an item like a function or struct private, you put it in a module.

  Summary:
    Rust lets you split a package into multiple crates and a crate into modules..
    Modules (code packed in a scope) is accessible by specifying abs. or rel. paths.
    You can call the "use" keyword to acceere to find an item in a module tree, we use a path.
      A way of naming an item, such as a struct, function, or module.
      Simlarly to navigating a filesystem.
      An absolute path is the full path starting from a crate root.
      A relative path starts from the current module.
      A relative path uses self, super, or an identifier in the current module.

  https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html
    Packages and Crates

    https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html#modules-cheat-sheet
      Modules Cheat Sheet

    We can choose to make modules and the items within them public,
    which exposes them to allow external code to use and depend on them.


https://doc.rust-lang.org/book/ch08-00-common-collections.html
  Common Collections

    Vector: Vec<T> 
      Allows you to store a variable number of values next to each other.
      Puts all the values next to each other in memory.
      Creating an empty vector:
        > let v: Vec<i32> = Vec::new();
    String:
      Collection of characters (collections of bytes in essence).
    Hash map - or just map:
      Associate a value with a particular key.

  https://doc.rust-lang.org/book/ch08-01-vectors.html#reading-elements-of-vectors

  https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings

  https://doc.rust-lang.org/book/ch08-02-strings.html#strings-are-not-so-simple

  https://doc.rust-lang.org/book/ch08-03-hash-maps.html#storing-keys-with-associated-values-in-hash-maps

  https://doc.rust-lang.org/book/ch08-03-hash-maps.html#creating-a-new-hash-map


https://doc.rust-lang.org/book/ch09-00-error-handling.html
  Error Handling

    Some Rust builtins
      panic!() -> calls the panic!() macro and panics the program
        > panic!("Problem opening the file: {:?}", variable)
      .unwrap() -> Calls panic!() for us with default message based on context
        > use std::fs::File;
        > File::open("hello.txt").unwrap()
      .expect() -> Calls panic!() for us with custom message
        > use std::fs::File;
        > let greeting_file = File::open("hello.txt").expect("hello.txt not found");

      Note: ..most Rustaceans choose expect rather than unwrap for giving precise context.

    Show backtrace when panic occours by running:
      $ RUST_BACKTRACE=1 cargo run
        ..we should start our investigation at the location pointed to
        ..by the first line mentioning a file WE wrote.

    When your code panics in the future,
    figure out what action the code is taking,
    with what values it got that caused the panic,
    and what the code should do instead.

    Rust groups errors into two major categories: recoverable and unrecoverable errors.
    Examples:
      - recoverable: file not found
      - unrecoverable: access a location beyond the end of an array

    Rust doesnt have exceptions. Instead, it has the type Result<T, E> for recoverable errors
    and the panic! macro that stops execution when the program encounters an unrecoverable error

  https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#recoverable-errors-with-result
    Most errors arent serious enough to require the program to stop entirely.
    Sometimes, when a function fails, its for a reason.
    One that you can easily interpret and respond to.
    For example opening a file that does not exist (at least yet)..
  
  https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#propagating-errors
    Propagating Errors

      Propagating:
        ..when a functions implementation calls something that might fail,
        instead of handling the error within the function itself,
        you can return the error to the calling code
        so that it can decide what to do.

        Basically -> send the error back to the code that calls the function

    https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator

  https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation


https://doc.rust-lang.org/book/ch10-00-generics.html
  Generic Types, Traits, and Lifetimes
    We use generics to create definitions for items like function signatures or structs,
    which we can then use with many different concrete data types..

    enerics are abstract stand-ins for concrete types or other properties.
    We have used these so far
      - Option<T>
      - Vec<T>
      - HashMap<K, V>
      - Result<T, E>

  Using generic types will not make your program run slower.
  Rust performes monomorphization of the code using generics at compile time.
  Monomorphization is the process of turning generic code into specific code
  by filling in the concrete types that are used when compiled.

  https://doc.rust-lang.org/book/ch10-01-syntax.html
    ..how to define functions, structs, enums, and methods using generics

    Used to handle the input of a variable that could possibly hold different concrete types.
    for example if you want to write a function that handles both u32 AND a character,
    we need to create a generic type for this.

    https://doc.rust-lang.org/book/ch10-01-syntax.html#in-function-definitions

    https://doc.rust-lang.org/book/ch10-01-syntax.html#in-struct-definitions
