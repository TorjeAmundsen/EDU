Chapter 1 - Getting Started
https://doc.rust-lang.org/book/ch01-01-installation.html

https://doc.rust-lang.org/book/ch01-02-hello-world.html

https://doc.rust-lang.org/book/ch01-03-hello-cargo.html
  Cargo - the build system and package manager
    It does multiple things:
      - building your code
      - downloading the libraries (dependencies)
      - checks code
      - runs the code

    create and run a new project
      $ cargo new <project_name>
        source files will live inside the <project_name>/src
      $ cd <project_name>
        cd into the project directory to run additional cargo commands
      $ cargo build
        creates build directory target/debug
        then compiles binary and places it in ./target/debug/<project_name>
      $ cargo build --release
        compile it with optimizations (faster execution)
        NOTE: creates an executable in target/release instead of target/debug
      $ cargo run
        same as cargo build, but also runs the binary if compile succeeded
        ..most developers use cargo run
      $ cargo check
        build a project without producing a binary to check for errors

    Crates
      packages of code are referred to as crates

    Cargo.lock
      Keeps track of the exact versions of dependencies in your project.
      We do not ever need to change this file manually.
      Cargo manages its contents for you.


Chapter 2 - Guessing Game
https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html
  $ cargo new guessing_game
  $ cd guessing_game

  Importing and "Prelude".
    Manually importing every single thing that you use is very verbose.
    Automatically importing a lot of things that a program never uses is bloat.
    A balance needs to be struck and that is the Prelude.
    The prelude is the list of things that Rust automatically imports into every Rust program.

    The use statement.
      Importing is don with "use".

  Importing standard io library (bringing the library into scope)
    > use std::io;
      this is used read input and writing output etc.

  Variables.
    > let mut <name> = <value>;

    immutable
      > let apples = 5;
    mutable
      > let mut bananas = 5;

  Types
    String: growable UTF-8 encoded bit of text

  Syntax
    :: Is an associated function of a type.
      > String::new();
        new is associated with the String type
        new creates a new, empty string..

    .name() Is a method
      > io::stdin()
      >   .read_line(&mut some_var)
        here the read_line() is a method on stdin()

    & Is a reference
      > .read_line(&mut some_var)
        referencing "some_var" Note: references are immutable

    io::stdin().read_line() returns a "Result" value which is an "enumeration" (enum)
      used to encode error-handling information with variants Ok and Err
      enums are covered in chapter 6..
      the "Result" value has an expect method
      if value is Err -> expect(argument) will cause the program to crash and display the message passed as argument
        most likely it would be OS related in this very case..

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#generating-a-secret-number
  Generate secret number using a "crate"
    ..a crate is a collection of Rust source code files

  $ cargo build
  Cargo.lock
    Rust creates the Cargo.lock file the first time you run cargo build.
    This will force the use of same version if new versions of dependency is released.
    This will reproduce builds identical to previous builds on unchanged source code.

  $ cargo update
    Ignore the Cargo.lock file and figure out all the latest versions in Cargo.toml.
    It will still not update to new "major" versions, only "minor" versions.
      see https://semver.org/

  $ cargo doc --open
    Automatically build documentation (HTML) provided for all dependencies
    It will open your default browser when done.
      If you are interested in other functionality in the rand crate,
      run cargo doc --open and click rand in the sidebar on the left.


Chapter 3 - Common Programming Concepts
https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html
  Rust encourages immutability, and this is the standard for variables unless specified.
    can not change
      > let  x = 5;
    can change
      > let mut x = 5;
    can not change, ever (should always be written in upper case)
      const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
        the result is calculated at compile time so that on execution time it does not have to

  Shadowing (assign new value to immutable variable)
    Rust helps you avoid creating duplicate variables with unique names.
    Creating a new variable with same name as an existing one will "shadow" the old value with new.
    Shadows are scope related, an inner scope does not shadow a variable from an outer scope.
    When shadowing, the variable might also change type, not only value.


https://doc.rust-lang.org/book/ch03-02-data-types.html
  Data Types

  Type anotation
    specify type when declaring variables (sometimes required like in the line below)
    > let guess: u32 = "42".parse().expect("Not a number!");
      it is the value after :, in this case the anotation is "u32"

  Integers (integer types default to i32 if not specified)
    Length    Signed  Unsigned
    8-bit	    i8  	  u8
    16-bit	  i16     u16
    32-bit    i32     u32
    64-bit    i64     u64
    128-bit   i128    u128
    arch      isize   usize
      ..each variant can be either signed (can be negative) or unsigned (only positive)

      ..integer overflow (complement wrapping)
        Variable starts from 0 and adds overflow value.
        https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-overflow

  Floating points
    f32 is a 32 bit value with single-precision
    f64 is a 64 bit value with double precision


https://doc.rust-lang.org/book/ch03-03-how-functions-work.html
  Functions

https://doc.rust-lang.org/book/ch03-05-control-flow.html
  Control flow


Chapter 4 - Ownership - memory handling in Rust
https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html
  The Stack and the Heap
    Both are parts of memory, but are structured in different ways.
    Stack (stack based -> fast)
      Stores values in the order it gets them and removes the values in the opposite order.
        ..last in, first out e.g. push -> add and pop -> remove.
    Heap (allocation/pointer based -> slower)
      Is less organized: when you put data on the heap, you request a certain amount of memory space.
      The memory allocator finds an empty spot in the heap that is big enough, mark it as being used.
      It returns a pointer (the memory address of the location).
        ..this is called "allocating on the heap"
    When program calls a function,
      the values passed into the function
      and the functions local variables
      ..get pushed onto the stack.
    When the function is over,
      ..those values get popped off the stack.

  Following the ownership, the goal is to minimize the data stored as heap by..
    ..keep track of what parts of code are using data on the heap
    ..minimize the amount of data (especially duplicate) on the heap
    ..and cleaning up unused data on the heap,

  Ownership rules
    Each value has an owner.
    Only one owner at a time.
    When owner goes out of scope, value is dropped.

  Illustrating the ownership: https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-string-type

https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#references-and-borrowing


https://doc.rust-lang.org/book/ch04-03-slices.html
  The Slice Type
    ..slices let you reference a contiguous sequence of elements in a collection
    ..rather than the whole collection.

  A string slice is a reference to part of a String
    > let s = String::from("hello world");
    > let hello = &s[0..5];
    > let world = &s[6..11];


Chapter 5 - Structs
https://doc.rust-lang.org/book/ch05-00-structs.html
  Each struct you define is its own type.
  A function that takes a parameter of type Color cannot take a Point as an argument,
  even though both types are made up of the same primitive datatypes e.g. i32.

  https://doc.rust-lang.org/book/ch05-02-example-structs.html

  https://doc.rust-lang.org/book/ch05-02-example-structs.html#adding-useful-functionality-with-derived-traits

  https://doc.rust-lang.org/book/ch05-03-method-syntax.html

  Declaring structs:
    > struct Rectangle {
    >   width: u32,
    >   height: u32,
    > }

  Implement methods to the struct:
    > impl Rectangle {
    >   fn area(&self) -> u32 {
    >     self.width * self.height
    >   }
    > }

  Instantiate struct:
    > let rect = Rectangle {
    >   width: 30,
    >   height: 50,
    > };

  Call method on struct object:
    > rect.area();


Chapter 6 - Enums and pattern matching
https://doc.rust-lang.org/book/ch06-00-enums.html
  ..setting a single value from a set of possible values.
  For example, we may want to say that Rectangle is one of a set of possible shapes.
  The shapes may include Circle and Triangle etc..
  Rust allows encoding these possibilities as an enum.

  Declare enum:
    > enum IpAddr {
    >   V4(u8, u8, u8, u8),
    >   V6(String),
    > }

  Instantiate enum (example for both V4 and V6):
    > let home = IpAddr::V4(127, 0, 0, 1);
    > let loopback = IpAddr::V6(String::from("::1"));

  The instance is namespaced under its identifier, in this example it is "IpAddr".
  Notice that we use a double colon to separate the two.

  Define a function that takes the custom enum type:
  > fn route(ip_kind: IpAddr) {....}

  Note that we can define a function that takes any IpAddr to handle both cases V4 and V6.

  https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values
    Rust doesn't have the null feature that many other languages have.
    Option is an enum defined by the standard library.
    It encodes a common scenario in which a value could be something or nothing (e.g. null).

    Combining match and enums is useful in many situations.

  https://doc.rust-lang.org/book/ch06-03-if-let.html
    if let - Syntax that lets you assign value if condition is true and then run associated code.


Chapter 7 - Managing Growing Projects with Packages, Crates, and Modules
https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
  Keywords:
    mod     -> define a module
    pub     -> make an item public (module, struct, enum, function..)
    super   -> refernece item in parent module (kinda like "cd .." in a unix filesystem)
    use     -> used to shorten the path required to refer to a module item (kinda like symlink in a unix filesystem)
    pub use -> re-export code (now external source code can access the the code in this file)
    as      -> change name of something imported with "use"

    Creating a library with the command:
      $ cargo new my_library_name --lib

    Crate:
      A tree of modules that produces a library or executable.
      Is the smallest piece of code the compiler considers at a time.
      It can be as simple as one file with a main function.
      It can be either a Binary crate or a Library crate.
        Binary crates comiles to a program.
          Crate root is src/main.rs
        Library crates have no main function and does not compile to a program.
          Crate root is src/lib.rs
      Cargo passes the crate root files to rustc to build the library or binary.

    Package:
      A Cargo feature that lets you build, test, and share crates.
      Is a bundle of one or more crates.
      Contains a Cargo.toml file that describes how to build those crates.
      Can have only one library crate.
      Can have multiple binary crates placing files in the src/bin directory (each file as a separate binary crate).
      Must contain at least one crate, whether thats a library or binary crate.

    Modules (and use):
      For organization of the scope and privacy of paths in a crate.
      Code within a module is private by default and can be made public.
      To structure a crate, we organize its functions into nested modules.

    Path:
      To show Rust where in the module tree it can find functions, methods, structs etc.
      ..are private to parent modules by default.
      If you want to make an item like a function or struct private, you put it in a module.

  Summary:
    Rust lets you split a package into multiple crates and a crate into modules..
    Modules (code packed in a scope) is accessible by specifying abs. or rel. paths.
    You can call the "use" keyword to acceere to find an item in a module tree, we use a path.
      A way of naming an item, such as a struct, function, or module.
      Simlarly to navigating a filesystem.
      An absolute path is the full path starting from a crate root.
      A relative path starts from the current module.
      A relative path uses self, super, or an identifier in the current module.

  https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html
    Packages and Crates

    https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html#modules-cheat-sheet
      Modules Cheat Sheet

    We can choose to make modules and the items within them public,
    which exposes them to allow external code to use and depend on them.


Chapter 8 - Common Collections
https://doc.rust-lang.org/book/ch08-00-common-collections.html
  Vector: Vec<T>
    Allows you to store a variable number of values next to each other.
    Puts all the values next to each other in memory.
    Creating an empty vector:
      > let v: Vec<i32> = Vec::new();
  String:
    Collection of characters (collections of bytes in essence).
  Hash map - or just map:
    Associate a value with a particular key.

  https://doc.rust-lang.org/book/ch08-01-vectors.html#reading-elements-of-vectors

  https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings

  https://doc.rust-lang.org/book/ch08-02-strings.html#strings-are-not-so-simple

  https://doc.rust-lang.org/book/ch08-03-hash-maps.html#storing-keys-with-associated-values-in-hash-maps

  https://doc.rust-lang.org/book/ch08-03-hash-maps.html#creating-a-new-hash-map


Chapter 9 - Error Handling
https://doc.rust-lang.org/book/ch09-00-error-handling.html
  Some Rust builtins
    panic!() -> calls the panic!() macro and panics the program
      > panic!("Problem opening the file: {:?}", variable)
    .unwrap() -> Calls panic!() for us with default message based on context
      > use std::fs::File;
      > File::open("hello.txt").unwrap()
    .expect() -> Calls panic!() for us with custom message
      > use std::fs::File;
      > let greeting_file = File::open("hello.txt").expect("hello.txt not found");

    Note: ..most Rustaceans choose expect rather than unwrap for giving precise context.

    Show backtrace when panic occours by running:
      $ RUST_BACKTRACE=1 cargo run
        ..we should start our investigation at the location pointed to
        ..by the first line mentioning a file WE wrote.

    When your code panics in the future,
    figure out what action the code is taking,
    with what values it got that caused the panic,
    and what the code should do instead.

    Rust groups errors into two major categories: recoverable and unrecoverable errors.
    Examples:
      - recoverable: file not found
      - unrecoverable: access a location beyond the end of an array

    Rust doesnt have exceptions. Instead, it has the type Result<T, E> for recoverable errors
    and the panic! macro that stops execution when the program encounters an unrecoverable error

  https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#recoverable-errors-with-result
    Most errors arent serious enough to require the program to stop entirely.
    Sometimes, when a function fails, its for a reason.
    One that you can easily interpret and respond to.
    For example opening a file that does not exist (at least yet)..

  https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#propagating-errors
    Propagating Errors

      Propagating:
        ..when a functions implementation calls something that might fail,
        instead of handling the error within the function itself,
        you can return the error to the calling code
        so that it can decide what to do.

        Basically -> send the error back to the code that calls the function

    https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator

  https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation


Chapter 10 - Generic Types, Traits, and Lifetimes
https://doc.rust-lang.org/book/ch10-00-generics.html
  We use generics to create definitions for items like function signatures or structs,
  which we can then use with many different concrete data types..

  enerics are abstract stand-ins for concrete types or other properties.
  We have used these so far
    - Option<T>
    - Vec<T>
    - HashMap<K, V>
    - Result<T, E>

  Using generic types will not make your program run slower.
  Rust performes monomorphization of the code using generics at compile time.
  Monomorphization is the process of turning generic code into specific code
  by filling in the concrete types that are used when compiled.

  https://doc.rust-lang.org/book/ch10-01-syntax.html
    ..how to define functions, structs, enums, and methods using generics

    Used to handle the input of a variable that could possibly hold different concrete types.
    for example if you want to write a function that handles both u32 AND a character,
    we need to create a generic type for this.

    https://doc.rust-lang.org/book/ch10-01-syntax.html#in-function-definitions

    https://doc.rust-lang.org/book/ch10-01-syntax.html#in-struct-definitions

  https://doc.rust-lang.org/book/ch10-02-traits.html
    Traits - defines functionality a particular type has and can share with other types.
    NOTE: Traits are similar to "interfaces" in other languages, although with some differences.

    A type's behavior consists of the methods we can call on that type.
    Different types "share the same behavior" if we can "call the same methods" on all of them.

    Trait definitions are a way to group method signatures together
    to define a set of behaviors necessary to accomplish some purpose.

    https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters
      Trait bounds in functions.

      Syntax for defining functions that takes trait as parameters

      Examplebelow uses 2 arbitraty traits with the names DisplayRender and PrintingReady

      2 examples for one parameter:
        > fn some_function(item: &impl DisplayRender) {..}

        > fn some_function<T: DisplayRender>(item: &T) {..}

      2 examples for multiple parameters, but same trait:
        > fn some_function(item1: &impl DisplayRender, item2: &impl DisplayRender) {..}

        > fn some_function<T: DisplayRender>(item1: &T, item2: &T) {..}

      2 examples with single parameter that takes multiple traits:
        > fn notify(item: &(impl DisplayRender + PrintingReady)) {..}

        > fn notify<T: DisplayRender + PrintingReady>(item: &T) {..}

      2 examples with multiple parameters and multiple traits:
        > fn some_function<T: DisplayRender + DisplayRender_v2, U: PrintingReady + PrintingReady_v2>(t: &T, u: &U) -> i32 {..}

        > fn some_function<T, U>(t: &T, u: &U) -> i32
          where
              T: DisplayRender + DisplayRender_v2,
              U: PrintingReady + PrintingReady_v2,
          {..}

    https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits


  https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
    Lifetimes

    When using references (pointers), Rust will sometimes need annotations about a lifetime.
    For example, if a function takes two references as parameter but only returns one of them,
    then there is no clear way how to deal with this from a compiler point of view.

    The functoin below is an example showing this exact scenario.
      fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
          if x.len() > y.len() {
              x
          } else {
              y
          }
      }
      ..the lifetime of reference x might be longer or shorter than reference b,
      so we make it clear that both follow the annotation 'a
      meaning that they both are suddenly limited to whichever had the shortest
      lifetime to begin when they where passed into this function.


Chapter 11 - Automated Testing
https://doc.rust-lang.org/book/ch11-00-testing.html
  Automated tests - A function that's annotated with the test attribute.

  Created the directory adder with command: cargo new adder --lib

  Run test command:
    Run all tests (in parallel) -> default option
      $ cargo test
    Run all tests consecutively -> hence the 1 thread option
      $ cargo test -- --test-threads=1
    Run only ignored tests
      $ cargo test -- --ignored
    Run all tests (including ignored)
      $ cargo test -- --include-ignored
    See printed values for passing tests
      $ cargo test -- --show-output
    Test all functions that matches part of the name or only the function that matches the full name
      $ cargo test <name>
    Test only files inside ./tests directory that matches name
      $ cargo test --test <name>


  add #[test] on the line before function declaration:

  Run test with command: cargo test
    -> builds a test runner binary
    -> runs the annotated functions
    -> reports if test functions passes or fails

  The body of a test function usually includes these.
    1. Set up any needed data or state.
    2. Run the code you want to test.
    3. Assert the results are what you expect.

  https://doc.rust-lang.org/book/ch11-02-running-tests.html#controlling-how-tests-are-run
    Controlling how tests are run.

  https://doc.rust-lang.org/book/ch11-03-test-organization.html#test-organization
    Test organization
      Unit tests
        - testing one module in isolation at a time
        - pinpoint where code is not working
        - small and more focused
        - can test private interfaces
        The convention is to create a module named tests in each file to contain the test
        functions and to annotate the module with cfg(test).

      Integration tests
        - using only the public interface and potentially exercising multiple modules per test
        - entirely external to your library
        - use your library/code in the same way any other external code would
        - test whether many parts of your library work together correctly
        Folder structure for integration test:
          mylibrary
          ├── Cargo.lock
          ├── Cargo.toml
          ├── src
          │   └── lib.rs
          └── tests
              ├── common
              │   └── mod.rs
              └── integration_test.rs


Chapter 12 - Building a CLI Program
https://doc.rust-lang.org/book/ch12-00-an-io-project.html
  An I/O Project: Building a Command Line Program

  Building a "grep" alternative.
  Our grep project will combine a number of concepts you've learned so far:
      Organizing code (using what you learned about modules in Chapter 7)
      Using vectors and strings (collections, Chapter 8)
      Handling errors (Chapter 9)
      Using traits and lifetimes where appropriate (Chapter 10)
      Writing tests (Chapter 11)

  https://doc.rust-lang.org/book/ch12-01-accepting-command-line-arguments.html#accepting-command-line-arguments
    Accepting commandline arguments

  https://doc.rust-lang.org/book/ch12-04-testing-the-librarys-functionality.html
    Just moved some part of the code from src/main.rs to src/lib.rs.

  https://doc.rust-lang.org/book/ch12-05-working-with-environment-variables.html
    Environment variables

    Creating a test that tests ignore case
    Creating a search function that ignores case
    Creating an additional config value (boolean) for ignore_case

  https://doc.rust-lang.org/book/ch12-06-writing-to-stderr-instead-of-stdout.html
    Write errors to stderr (instead of stdout)
      almost identical to println, but with a leading "e"
      > eprintln!("some error :/")


Chapter 13 - Functional Language Features
https://doc.rust-lang.org/book/ch13-00-functional-features.html
  Iterators and Closures
    Expressing high-level ideas at low-level performance
    Covering:
      - Closures, a function-like construct you can store in a variable
      - Iterators, a way of processing a series of elements
      - How to use closures and iterators to improve project in Chapter 12
      - The performance of closures and iterators

  https://doc.rust-lang.org/book/ch13-01-closures.html
    closures:
      - anonymous functions you can put in a variable
      - the variable can be called or passed to another function
      - captures values from the scope in which they're defined

    The shortest possible closure definition:
      > let example_closure = |x| x;
    ..it just returns the value it is passed

    declaring closures with annotation (4 examples)
      > fn  add_one_v1   (x: u32) -> u32 { x + 1 }
      > let add_one_v2 = |x: u32| -> u32 { x + 1 };
      > let add_one_v3 = |x|             { x + 1 };
      > let add_one_v4 = |x|               x + 1  ;
    These will produce the same behavior when they're called.
    The add_one_v3 and add_one_v4 lines require the closures to be evaluated
    ..to be able to compile because the types will be inferred from their usage.

    https://doc.rust-lang.org/book/ch13-01-closures.html#capturing-references-or-moving-ownership
      closure will decide how to handle ownership for passed values
        - borrowing immutably
        - borrowing mutably
        - taking ownership
      ..based on what the body of the function does with the captured values

      example:
        > let list = vec![1, 2, 3];
        > let my_closure = || println!("From closure: {:?}", list);
        >
        > my_closure();                                 // println!() does noly need to borrow
        > println!("after calling closure {:?}", list); // that means the list is still available

    https://doc.rust-lang.org/book/ch13-01-closures.html#moving-captured-values-out-of-closures-and-the-fn-traits
      The way a closure captures and handles values from the environment affects which traits the closure implements.
      There are 3 traits, FnOnce, FnMut and Fn.
      Closures will automatically implement one, two, or all three of these Fn traits,
      depending on how the closure's body handles the values.
        FnOnce:
          Closure that moves captured values out of its body will only implement FnOnce
          These can only be called called once.
        FnMut:
          Might mutate the captured values, but does not move captured values out of their body.
        Fn:
          Dont move captured values out of their body.
          Dont mutate captured values.
          Captures nothing from their environment

  https://doc.rust-lang.org/book/ch13-02-iterators.html
    Iterators
      - All iterators implement a trait named Iterator (defined in the standard library).
      - The Iterator trait only requires implementors to define one method: the next method
      - The next method returns one item of the iterator at a time wrapped in Some.
      - The next method returns None When iteration is over.

      The definition of the iterator trait in the std lib looks like this:
        > pub trait Iterator {
        >     type Item;
        >     fn next(&mut self) -> Option<Self::Item>;
        > }

  https://doc.rust-lang.org/book/ch13-03-improving-our-io-project.html
    Improving our i/o project - minigrep

  https://doc.rust-lang.org/book/ch13-04-performance.html#comparing-performance-loops-vs-iterators
    Comparing Performance: Loops vs. Iterators
    Iterators make code seem like it’s higher level and might imply runtime performance penalty.
    This is not the case.
    Iterators are one of Rust’s zero-cost abstractions.
    Using the abstraction (for iterators in this context) should imposes no additional runtime overhead.

    Unrolling is another optimization that Rust does at compile-time.
    It removes overhead of a loop and instead generates repetitive code for each iteration of the loop.


Chapter 14 - 
https://doc.rust-lang.org/book/ch14-00-more-about-cargo.html
  - Customize your build through release profiles
  - Publish libraries on crates.io
  - Organize large projects with workspaces
  - Install binaries from crates.io
  - Extend Cargo using custom commands
  Even more (outside the scope of this chapter) can be found here: https://doc.rust-lang.org/cargo/

  Release profiles are predefined and customizable profiles with different configurations.
  They allow a programmer to have more control over various options for compiling code.
  Each profile is configured independently of the others.
  Profiles can be configured in the Cargo.toml file.

  Cargo has two main profiles:
    1. dev     -> mainly less optimization when compiling, invoked when running cargo build
    2. release -> mainly more optimization when compiling, invoked when running cargo build --release

  Read about profiles here:  https://doc.rust-lang.org/cargo/reference/profiles.html

https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html
  Publishing a Crate to Crates.io
  Make a new crate running $ cargo new --lib <name>.

  The crate registry at crates.io distributes the source code of your packages.
  It primarily hosts code that is open source.

  Document-comments - Making documentation for your crate.
  Documentation comments use three slashes ///.
  This will generate HTML documentation.
  Code existing in these comments will also be tested when running $ cargo test.
  It supports Markdown notation for formatting the text.
  Place documentation comments just before the item (function, struct, method etc.).

  Generate documentation from source code, in the project directory run:
    $ cargo doc
  Generated HTML documentation will appear in the target/doc directory

  You can also generate and view documentation in one go, in the project directory run:
    $ cargo doc --open
  A web-browser spawns with all your documentation.

https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#commonly-used-sections
  Commonly Used Sections

https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#documentation-comments-as-tests
  documentation comments runs tests
    $ cargo test
    ..will run the code examples in your documentation as tests!

https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#exporting-a-convenient-public-api-with-pub-use
  Exporting a Convenient Public API with pub use
  If your structure is inconvenient for users. If users might be annoyed at having to enter
    > use my_crate::some_module::another_module::UsefulType;
  rather than
    > use my_crate::UsefulType;.
  ..you can re-export items to make a public structure that’s different from your private structure by using
  examples from rust-book:
    > pub use self::kinds::PrimaryColor;
    > pub use self::kinds::SecondaryColor;
    > pub use self::utils::mix;
  ..it decouples the internal structure from what you present to your users

https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#setting-up-a-cratesio-account
  Sign into https://crates.io.
  Retrieve your API key from https://crates.io/me/.
  Run the cargo login command with your API key
    $ cargo login <api-key>
  ..will inform Cargo of your API token and store it locally in ~/.cargo/credentials
  Api token is secret. If compromisd, revoke it and generate a new token on crates.io.

https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#adding-metadata-to-a-new-crate
  Adding Metadata to a New Crate
  Before publishing, add metadata in the [package] section of the crate’s Cargo.toml file.
  Your crate will need a unique name.
  Once a crate name in creates.io is taken, no one else can publish a crate with that name.

  Example of package section in a Cargo.toml file.
    [package]
    name = "guessing_game"
    version = "0.1.0"
    edition = "2021"
    description = "A fun game where you guess what number the computer has chosen."
    license = "MIT OR Apache-2.0"

https://doc.rust-lang.org/book/ch14-02-publishing-to-crates-io.html#publishing-to-cratesio
  Publishing to Crates.io
  Publish by running:
    $ cargo publish.
  A publish is permanent.
  The version can never be overwritten.
  The code cannot be deleted.
  This is by design - the goal of crates.io is to act as a permanent archive.
  Builds of all projects that depend on crates from crates.io will always continue to work.
  ..also, there are no limits to the number of crate versions you can publish.

  Publishing a New Version of an Existing Crate.
  Change the version value specified in your Cargo.toml
  Then run $ cargo publish, as earlier.

  Deprecated versions.
  Yanking a version prevents new projects from depending on that version
  Yanking means that all projects with a Cargo.lock will not break.
  Any future Cargo.lock files generated will not use the yanked version.
  Yank version 1.0.1, run:
    $ cargo yank --vers 1.0.1
  Unyank version 1.0.1, run:
    $ cargo yank --vers 1.0.1 --undo
  NOTE: A yank does not delete any code.

https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html#cargo-workspaces
  Cargo Workspaces
  Imagine the library crate continues to get bigger.
  You want to split your package further into multiple library crates.
  Enter "workspace".
  A workspace is a set of packages that share one single Cargo.lock and one target directory.
  In the chapter-directory (14_More_about_Cargo_and_Crates_dot_io) I ran these commands.
  $ mkdir add # root directory for application
  $ cd add
  $ touch Cargo.toml # holding workspace section with the member-crates.
  $ cargo new adder # binary crate with main.rs
  $ cargo new add_one --lib
  $ cargo new add_two --lib
    Inside adder -> add/adder/Cargo.toml I added dependencies
      [dependencies]
      add_one = { path = "../add_one" }
      add_two = { path = "../add_two" }

    Inside add/Cargo.toml I added workspace members
      [workspace]
      members = [
          "adder",
          "add_one",
          "add_two",
      ]

  $ cargo build
  ..we end up with this structure
    ├── Cargo.lock
    ├── Cargo.toml
    ├── add_one
    │   ├── Cargo.toml
    │   └── src
    │       └── lib.rs
    ├── add_two
    │   ├── Cargo.toml
    │   └── src
    │       └── lib.rs
    ├── adder
    │   ├── Cargo.toml
    │   └── src
    │       └── main.rs
    └── target

  The workspace has one target directory at the top level.
  Cargo doesn’t assume that crates in a workspace will depend on each other.
  We need to be explicit about the dependency relationships.
  Section [dependencies] is where we state dependencies.
  We added "rand" as dependency for both crates
    add/add_one/src/lib.rs (add/add_one/Cargo.toml)
    add/adder/src/main.rs (add/adder/Cargo.toml)
  Cargo.lock in the root directory will handle both to makes sure intercompatibility between crates. 

  If you publish the crates in the workspace to crates.io,
  each crate in the workspace will need to be published separately.
  Publish a particular crate in our workspace using the -p flag specifying the name of the crate.

https://doc.rust-lang.org/book/ch14-04-installing-binaries.html
  Install binaries with cargo
  A convenient way for Rust developers to install tools that others have shared on crates.io
    $ cargo install <cargo>
      - can only install packages that have binary targets (crate has src/main.rs another file specified as a binary)
        ..library target isn’t runnable on its own
      - not intended to replace system packages
      - stored in $HOME/.cargo/bin

  You run the binary issuing the cargo command (cargo subcommand).
  A binary named cargo-minigrep can be run with cargo minigrep


Chapter 15 - Smart Pointers
https://doc.rust-lang.org/book/ch15-00-smart-pointers.html
  Rusts basic pointer is a reference (indicated by the & and borrow the value they point to).
  Smart pointers - short summary:
    - data structures that act like a pointer with medatada and added capabilities.
    - in many cases own the data they point to.
    - implemented using structs
    - Unlike an ordinary struct, smart pointers implement the Deref and Drop traits
    - Many libraries have their own smart pointers
    - You can write your own smart pointers

  Deref trait:
    Allows an instance of the smart pointer struct to behave like a reference.
  
  Drop trait:
    Allows you to customize the code that’s run when an instance of the smart pointer goes out of scope.

  Mmost common smart pointers in the standard library:
    Box<T>:
      for allocating values on the heap
    Rc<T>:
      a reference counting type that enables multiple ownership
    Ref<T> (and RefMut<T>) accessed through RefCell<T>:
      a type that enforces the borrowing rules at runtime instead of compile time

https://doc.rust-lang.org/book/ch15-01-box.html#using-boxt-to-point-to-data-on-the-heap
  Boxes the Box<T> type.
  The most straight forward smart pointer.
  It allows you to store on heap instead of stack.
  Less capabilities and less overhead.
  It is used when..
    - you have a type whose size can’t be known at compile time
      and you want to use a value of that type in a context that requires an exact size
    - you have a large amount of data and you want to transfer ownership
      but ensure the data won’t be copied when you do so
    - you want to own a value and you care only that it’s a type that implements a particular trait
      rather than being of a specific type

  cons list - A recursive type - less commonly used datastructure in Rust.
  Vec<T> is the commonly used "list" type.
  The cons list is a type commonly found in functional programming languages.
  A data structure that comes from the Lisp programming language.
  Pseudocode representation of a cons list containing the list 1, 2, 3.
  > (1, (2, (3, Nil)))
  Each item in a cons list contains two elements: the value of the current item and the next item.
  A cons list is produced by recursively calling the cons function.
  Nil is the "base case" (where the recursion stops).

https://doc.rust-lang.org/book/ch15-02-deref.html#treating-smart-pointers-like-regular-references-with-the-deref-trait
  Deref Trait - Treating Smart Pointers Like Regular References
  Deref trait allows you to customize the behavior of the dereference operator *.
  By implementing Deref in such a way that a smart pointer can be treated like a regular reference,
  you can write code that operates on references and use that code with smart pointers too.

https://doc.rust-lang.org/book/ch15-03-drop.html
  Running Code on Cleanup with the Drop Trait
  The Drop trait lets you customize what happens when a value is about to go out of scope.
  You can implement Drop on any type.
  File-connections and network-connections are normal cases for the Drop trait.

https://doc.rust-lang.org/book/ch15-04-rc.html
  Rc<T>, the Reference Counted Smart Pointer
  Rc stadns for "Reference Counted".
  In essence:
    We use the Rc<T> type when we want to allocate some data on the heap for multiple parts of our program to read
    and we can’t determine at compile time which part will finish using the data last.
    Note that Rc<T> is only for use in single-threaded scenarios.
  In the majority of cases, ownership is clear: you know exactly which variable owns a given value.
  However, there are cases when a single value might have multiple owners.
  Enabling multiple ownership explicitly is done by using the Rust type Rc<T>.
  Rc<T> type keeps track of the number of references to a value determining if the value is still in use.
  If there are zero references to a value, the value can be cleaned up without any references becoming invalid.

https://doc.rust-lang.org/book/ch15-05-interior-mutability.html
  RefCell<T> and the Interior Mutability Pattern
  - Mutating the value inside an immutable value is the interior mutability pattern.

  Unlike Rc<T>, the RefCell<T> type represents single ownership over the data it holds.
    - References must always be valid.
    - At any given time, you can have either (but not both) one mutable reference
      or any number of immutable references.

  With RefCell<T> borrowing rules are checked during runtime.
  If you break these rules, the program will panic and exit.

  The advantage of checking the borrowing rules at runtime instead
  is that certain memory-safe scenarios are then allowed.

  If the Rust compiler can’t be sure the code complies with the ownership rules,
  it might reject a correct program.
  The RefCell<T> type is useful when you’re sure your code follows the borrowing rules
  but the compiler is unable to understand and guarantee that.

  RefCell (just like Rc) is only used for single threaded programs.

https://doc.rust-lang.org/book/ch15-05-interior-mutability.html#having-multiple-owners-of-mutable-data-by-combining-rct-and-refcellt
  Having Multiple Owners of Mutable Data by Combining Rc<T> and RefCell<T>


Chapter 16 - Fearless Concurrency
https://doc.rust-lang.org/book/ch16-00-concurrency.html
  Threads and communicating between them.
