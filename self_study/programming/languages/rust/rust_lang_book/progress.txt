https://doc.rust-lang.org/book/ch01-01-installation.html

https://doc.rust-lang.org/book/ch01-02-hello-world.html

https://doc.rust-lang.org/book/ch01-03-hello-cargo.html
  Cargo - the build system and package manager
    It does multiple things:
      - building your code
      - downloading the libraries (dependencies)
      - checks code
      - runs the code

    create and run a new project
      $ cargo new <project_name>
        source files will live inside the <project_name>/src
      $ cd <project_name>
        cd into the project directory to run additional cargo commands
      $ cargo build
        creates build directory target/debug
        then compiles binary and places it in ./target/debug/<project_name>
      $ cargo build --release
        compile it with optimizations (faster execution)
        NOTE: creates an executable in target/release instead of target/debug
      $ cargo run
        same as cargo build, but also runs the binary if compile succeeded
        ..most developers use cargo run
      $ cargo check
        build a project without producing a binary to check for errors

    Crates
      packages of code are referred to as crates

    Cargo.lock
      Keeps track of the exact versions of dependencies in your project.
      We do not ever need to change this file manually.
      Cargo manages its contents for you.

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html
  $ cargo new guessing_game
  $ cd guessing_game

  Importing and "Prelude".
    Manually importing every single thing that you use is very verbose.
    Automatically importing a lot of things that a program never uses is bloat.
    A balance needs to be struck and that is the Prelude.
    The prelude is the list of things that Rust automatically imports into every Rust program.

    The use statement.
      Importing is don with "use".

  Importing standard io library (bringing the library into scope)
    > use std::io;
      this is used read input and writing output etc.

  Variables.
    > let mut <name> = <value>;

    immutable
      > let apples = 5;
    mutable
      > let mut bananas = 5;

  Types
    String: growable UTF-8 encoded bit of text

  Syntax
    :: Is an associated function of a type.
      > String::new();
        new is associated with the String type
        new creates a new, empty string..

    .name() Is a method
      > io::stdin()
      >   .read_line(&mut some_var)
        here the read_line() is a method on stdin()

    & Is a reference
      > .read_line(&mut some_var)
        referencing "some_var" Note: references are immutable

    io::stdin().read_line() returns a "Result" value which is an "enumeration" (enum)
      used to encode error-handling information with variants Ok and Err
      enums are covered in chapter 6..
      the "Result" value has an expect method
      if value is Err -> expect(argument) will cause the program to crash and display the message passed as argument
        most likely it would be OS related in this very case..

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#generating-a-secret-number
  Generate secret number using a "crate"
    ..a crate is a collection of Rust source code files

  $ cargo build
  Cargo.lock
    Rust creates the Cargo.lock file the first time you run cargo build.
    This will force the use of same version if new versions of dependency is released.
    This will reproduce builds identical to previous builds on unchanged source code.

  $ cargo update
    Ignore the Cargo.lock file and figure out all the latest versions in Cargo.toml.
    It will still not update to new "major" versions, only "minor" versions.
      see https://semver.org/

  $ cargo doc --open
    Automatically build documentation (HTML) provided for all dependencies
    It will open your default browser when done.
      If you are interested in other functionality in the rand crate,
      run cargo doc --open and click rand in the sidebar on the left.


https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html
  Common Programming Concepts

  Rust encourages immutability, and this is the standard for variables unless specified.
    can not change
      > let  x = 5;
    can change
      > let mut x = 5;
    can not change, ever (should always be written in upper case)
      const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
        the result is calculated at compile time so that on execution time it does not have to

  Shadowing (assign new value to immutable variable)
    Rust helps you avoid creating duplicate variables with unique names.
    Creating a new variable with same name as an existing one will "shadow" the old value with new.
    Shadows are scope related, an inner scope does not shadow a variable from an outer scope.
    When shadowing, the variable might also change type, not only value.


https://doc.rust-lang.org/book/ch03-02-data-types.html
  Data Types

  Type anotation
    specify type when declaring variables (sometimes required like in the line below)
    > let guess: u32 = "42".parse().expect("Not a number!");
      it is the value after :, in this case the anotation is "u32"

  Integers (integer types default to i32 if not specified)
    Length    Signed  Unsigned
    8-bit	    i8  	  u8
    16-bit	  i16     u16
    32-bit    i32     u32
    64-bit    i64     u64
    128-bit   i128    u128
    arch      isize   usize
      ..each variant can be either signed (can be negative) or unsigned (only positive)

      ..integer overflow (complement wrapping)
        Variable starts from 0 and adds overflow value.
        https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-overflow

  Floating points
    f32 is a 32 bit value with single-precision
    f64 is a 64 bit value with double precision


https://doc.rust-lang.org/book/ch03-03-how-functions-work.html
  Functions

https://doc.rust-lang.org/book/ch03-05-control-flow.html
  Control flow

https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html
  Ownership - memory handling in Rust

    The Stack and the Heap
      Both are parts of memory, but are structured in different ways.
      Stack (stack based -> fast)
        Stores values in the order it gets them and removes the values in the opposite order.
          ..last in, first out e.g. push -> add and pop -> remove.
      Heap (allocation/pointer based -> slower)
        Is less organized: when you put data on the heap, you request a certain amount of memory space.
        The memory allocator finds an empty spot in the heap that is big enough, mark it as being used.
        It returns a pointer (the memory address of the location).
          ..this is called "allocating on the heap"
      When program calls a function,
        the values passed into the function
        and the functions local variables
        ..get pushed onto the stack.
      When the function is over,
        ..those values get popped off the stack.

  Following the ownership, the goal is to minimize the data stored as heap by..
    ..keep track of what parts of code are using data on the heap
    ..minimize the amount of data (especially duplicate) on the heap
    ..and cleaning up unused data on the heap,

  Ownership rules
    Each value has an owner.
    Only one owner at a time.
    When owner goes out of scope, value is dropped.

  Illustrating the ownership: https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-string-type

https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#references-and-borrowing


https://doc.rust-lang.org/book/ch04-03-slices.html
  The Slice Type
    ..slices let you reference a contiguous sequence of elements in a collection
    ..rather than the whole collection.

  A string slice is a reference to part of a String
    > let s = String::from("hello world");
    > let hello = &s[0..5];
    > let world = &s[6..11];


https://doc.rust-lang.org/book/ch05-00-structs.html
  Structs

  Each struct you define is its own type.
  A function that takes a parameter of type Color cannot take a Point as an argument,
  even though both types are made up of the same primitive datatypes e.g. i32.

  https://doc.rust-lang.org/book/ch05-02-example-structs.html

  https://doc.rust-lang.org/book/ch05-02-example-structs.html#adding-useful-functionality-with-derived-traits

  https://doc.rust-lang.org/book/ch05-03-method-syntax.html

  Declaring structs:
    > struct Rectangle {
    >   width: u32,
    >   height: u32,
    > }

  Implement methods to the struct:
    > impl Rectangle {
    >   fn area(&self) -> u32 {
    >     self.width * self.height
    >   }
    > }

  Instantiate struct:
    > let rect = Rectangle {
    >   width: 30,
    >   height: 50,
    > };

  Call method on struct object:
    > rect.area();


https://doc.rust-lang.org/book/ch06-00-enums.html
  Enums and pattern matching

  ..setting a single value from a set of possible values.
  For example, we may want to say that Rectangle is one of a set of possible shapes.
  The shapes may include Circle and Triangle etc..
  Rust allows encoding these possibilities as an enum.

  Declare enum:
    > enum IpAddr {
    >   V4(u8, u8, u8, u8),
    >   V6(String),
    > }

  Instantiate enum (example for both V4 and V6):
    > let home = IpAddr::V4(127, 0, 0, 1);
    > let loopback = IpAddr::V6(String::from("::1"));

  The instance is namespaced under its identifier, in this example it is "IpAddr".
  Notice that we use a double colon to separate the two.

  Define a function that takes the custom enum type:
  > fn route(ip_kind: IpAddr) {....}

  Note that we can define a function that takes any IpAddr to handle both cases V4 and V6.

  https://doc.rust-lang.org/book/ch06-01-defining-an-enum.html#the-option-enum-and-its-advantages-over-null-values
    Rust doesn't have the null feature that many other languages have.
    Option is an enum defined by the standard library.
    It encodes a common scenario in which a value could be something or nothing (e.g. null).

    Combining match and enums is useful in many situations.

  https://doc.rust-lang.org/book/ch06-03-if-let.html
    if let - Syntax that lets you assign value if condition is true and then run associated code.


https://doc.rust-lang.org/book/ch07-00-managing-growing-projects-with-packages-crates-and-modules.html
  Managing Growing Projects with Packages, Crates, and Modules

    Keywords:
      mod     -> define a module
      pub     -> make an item public (module, struct, enum, function..)
      super   -> refernece item in parent module (kinda like "cd .." in a unix filesystem)
      use     -> used to shorten the path required to refer to a module item (kinda like symlink in a unix filesystem)
      pub use -> re-export code (now external source code can access the the code in this file)
      as      -> change name of something imported with "use"

    Creating a library with the command:
      $ cargo new my_library_name --lib

    Crate:
      A tree of modules that produces a library or executable.
      Is the smallest piece of code the compiler considers at a time.
      It can be as simple as one file with a main function.
      It can be either a Binary crate or a Library crate.
        Binary crates comiles to a program.
          Crate root is src/main.rs
        Library crates have no main function and does not compile to a program.
          Crate root is src/lib.rs
      Cargo passes the crate root files to rustc to build the library or binary.

    Package:
      A Cargo feature that lets you build, test, and share crates.
      Is a bundle of one or more crates.
      Contains a Cargo.toml file that describes how to build those crates.
      Can have only one library crate.
      Can have multiple binary crates placing files in the src/bin directory (each file as a separate binary crate).
      Must contain at least one crate, whether thats a library or binary crate.

    Modules (and use):
      For organization of the scope and privacy of paths in a crate.
      Code within a module is private by default and can be made public.
      To structure a crate, we organize its functions into nested modules.

    Path:
      To show Rust where in the module tree it can find functions, methods, structs etc.
      ..are private to parent modules by default.
      If you want to make an item like a function or struct private, you put it in a module.

  Summary:
    Rust lets you split a package into multiple crates and a crate into modules..
    Modules (code packed in a scope) is accessible by specifying abs. or rel. paths.
    You can call the "use" keyword to acceere to find an item in a module tree, we use a path.
      A way of naming an item, such as a struct, function, or module.
      Simlarly to navigating a filesystem.
      An absolute path is the full path starting from a crate root.
      A relative path starts from the current module.
      A relative path uses self, super, or an identifier in the current module.

  https://doc.rust-lang.org/book/ch07-01-packages-and-crates.html
    Packages and Crates

    https://doc.rust-lang.org/book/ch07-02-defining-modules-to-control-scope-and-privacy.html#modules-cheat-sheet
      Modules Cheat Sheet

    We can choose to make modules and the items within them public,
    which exposes them to allow external code to use and depend on them.


https://doc.rust-lang.org/book/ch08-00-common-collections.html
  Common Collections

    Vector: Vec<T>
      Allows you to store a variable number of values next to each other.
      Puts all the values next to each other in memory.
      Creating an empty vector:
        > let v: Vec<i32> = Vec::new();
    String:
      Collection of characters (collections of bytes in essence).
    Hash map - or just map:
      Associate a value with a particular key.

  https://doc.rust-lang.org/book/ch08-01-vectors.html#reading-elements-of-vectors

  https://doc.rust-lang.org/book/ch08-02-strings.html#indexing-into-strings

  https://doc.rust-lang.org/book/ch08-02-strings.html#strings-are-not-so-simple

  https://doc.rust-lang.org/book/ch08-03-hash-maps.html#storing-keys-with-associated-values-in-hash-maps

  https://doc.rust-lang.org/book/ch08-03-hash-maps.html#creating-a-new-hash-map


https://doc.rust-lang.org/book/ch09-00-error-handling.html
  Error Handling

    Some Rust builtins
      panic!() -> calls the panic!() macro and panics the program
        > panic!("Problem opening the file: {:?}", variable)
      .unwrap() -> Calls panic!() for us with default message based on context
        > use std::fs::File;
        > File::open("hello.txt").unwrap()
      .expect() -> Calls panic!() for us with custom message
        > use std::fs::File;
        > let greeting_file = File::open("hello.txt").expect("hello.txt not found");

      Note: ..most Rustaceans choose expect rather than unwrap for giving precise context.

    Show backtrace when panic occours by running:
      $ RUST_BACKTRACE=1 cargo run
        ..we should start our investigation at the location pointed to
        ..by the first line mentioning a file WE wrote.

    When your code panics in the future,
    figure out what action the code is taking,
    with what values it got that caused the panic,
    and what the code should do instead.

    Rust groups errors into two major categories: recoverable and unrecoverable errors.
    Examples:
      - recoverable: file not found
      - unrecoverable: access a location beyond the end of an array

    Rust doesnt have exceptions. Instead, it has the type Result<T, E> for recoverable errors
    and the panic! macro that stops execution when the program encounters an unrecoverable error

  https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#recoverable-errors-with-result
    Most errors arent serious enough to require the program to stop entirely.
    Sometimes, when a function fails, its for a reason.
    One that you can easily interpret and respond to.
    For example opening a file that does not exist (at least yet)..

  https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#propagating-errors
    Propagating Errors

      Propagating:
        ..when a functions implementation calls something that might fail,
        instead of handling the error within the function itself,
        you can return the error to the calling code
        so that it can decide what to do.

        Basically -> send the error back to the code that calls the function

    https://doc.rust-lang.org/book/ch09-02-recoverable-errors-with-result.html#a-shortcut-for-propagating-errors-the--operator

  https://doc.rust-lang.org/book/ch09-03-to-panic-or-not-to-panic.html#creating-custom-types-for-validation


https://doc.rust-lang.org/book/ch10-00-generics.html
  Generic Types, Traits, and Lifetimes
    We use generics to create definitions for items like function signatures or structs,
    which we can then use with many different concrete data types..

    enerics are abstract stand-ins for concrete types or other properties.
    We have used these so far
      - Option<T>
      - Vec<T>
      - HashMap<K, V>
      - Result<T, E>

  Using generic types will not make your program run slower.
  Rust performes monomorphization of the code using generics at compile time.
  Monomorphization is the process of turning generic code into specific code
  by filling in the concrete types that are used when compiled.

  https://doc.rust-lang.org/book/ch10-01-syntax.html
    ..how to define functions, structs, enums, and methods using generics

    Used to handle the input of a variable that could possibly hold different concrete types.
    for example if you want to write a function that handles both u32 AND a character,
    we need to create a generic type for this.

    https://doc.rust-lang.org/book/ch10-01-syntax.html#in-function-definitions

    https://doc.rust-lang.org/book/ch10-01-syntax.html#in-struct-definitions

  https://doc.rust-lang.org/book/ch10-02-traits.html
    Traits - defines functionality a particular type has and can share with other types.
    NOTE: Traits are similar to "interfaces" in other languages, although with some differences.

    A type's behavior consists of the methods we can call on that type.
    Different types "share the same behavior" if we can "call the same methods" on all of them.

    Trait definitions are a way to group method signatures together
    to define a set of behaviors necessary to accomplish some purpose.

    https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters
      Trait bounds in functions.

      Syntax for defining functions that takes trait as parameters

      Examplebelow uses 2 arbitraty traits with the names DisplayRender and PrintingReady

      2 examples for one parameter:
        > fn some_function(item: &impl DisplayRender) {..}

        > fn some_function<T: DisplayRender>(item: &T) {..}

      2 examples for multiple parameters, but same trait:
        > fn some_function(item1: &impl DisplayRender, item2: &impl DisplayRender) {..}

        > fn some_function<T: DisplayRender>(item1: &T, item2: &T) {..}

      2 examples with single parameter that takes multiple traits:
        > fn notify(item: &(impl DisplayRender + PrintingReady)) {..}

        > fn notify<T: DisplayRender + PrintingReady>(item: &T) {..}

      2 examples with multiple parameters and multiple traits:
        > fn some_function<T: DisplayRender + DisplayRender_v2, U: PrintingReady + PrintingReady_v2>(t: &T, u: &U) -> i32 {..}

        > fn some_function<T, U>(t: &T, u: &U) -> i32
          where
              T: DisplayRender + DisplayRender_v2,
              U: PrintingReady + PrintingReady_v2,
          {..}

    https://doc.rust-lang.org/book/ch10-02-traits.html#returning-types-that-implement-traits


  https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html
    Lifetimes

    When using references (pointers), Rust will sometimes need annotations about a lifetime.
    For example, if a function takes two references as parameter but only returns one of them,
    then there is no clear way how to deal with this from a compiler point of view.

    The functoin below is an example showing this exact scenario.
      fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
          if x.len() > y.len() {
              x
          } else {
              y
          }
      }
      ..the lifetime of reference x might be longer or shorter than reference b,
      so we make it clear that both follow the annotation 'a
      meaning that they both are suddenly limited to whichever had the shortest
      lifetime to begin when they where passed into this function.

https://doc.rust-lang.org/book/ch11-00-testing.html
  Automated tests - A function that's annotated with the test attribute.

  Created the directory adder with command: cargo new adder --lib

  Run test command:
    Run all tests (in parallel) -> default option
      $ cargo test
    Run all tests consecutively -> hence the 1 thread option
      $ cargo test -- --test-threads=1
    Run only ignored tests
      $ cargo test -- --ignored
    Run all tests (including ignored)
      $ cargo test -- --include-ignored
    See printed values for passing tests
      $ cargo test -- --show-output
    Test all functions that matches part of the name or only the function that matches the full name
      $ cargo test <name>
    Test only files inside ./tests directory that matches name
      $ cargo test --test <name>


  add #[test] on the line before function declaration:

  Run test with command: cargo test
    -> builds a test runner binary
    -> runs the annotated functions
    -> reports if test functions passes or fails

  The body of a test function usually includes these.
    1. Set up any needed data or state.
    2. Run the code you want to test.
    3. Assert the results are what you expect.

  https://doc.rust-lang.org/book/ch11-02-running-tests.html#controlling-how-tests-are-run
    Controlling how tests are run.

  https://doc.rust-lang.org/book/ch11-03-test-organization.html#test-organization
    Test organization
      Unit tests
        - testing one module in isolation at a time
        - pinpoint where code is not working
        - small and more focused
        - can test private interfaces
        The convention is to create a module named tests in each file to contain the test
        functions and to annotate the module with cfg(test).

      Integration tests
        - using only the public interface and potentially exercising multiple modules per test
        - entirely external to your library
        - use your library/code in the same way any other external code would
        - test whether many parts of your library work together correctly
        Folder structure for integration test:
          mylibrary
          ├── Cargo.lock
          ├── Cargo.toml
          ├── src
          │   └── lib.rs
          └── tests
              ├── common
              │   └── mod.rs
              └── integration_test.rs


https://doc.rust-lang.org/book/ch12-00-an-io-project.html
  An I/O Project: Building a Command Line Program

  Building a "grep" alternative.
  Our grep project will combine a number of concepts you've learned so far:
      Organizing code (using what you learned about modules in Chapter 7)
      Using vectors and strings (collections, Chapter 8)
      Handling errors (Chapter 9)
      Using traits and lifetimes where appropriate (Chapter 10)
      Writing tests (Chapter 11)

  https://doc.rust-lang.org/book/ch12-01-accepting-command-line-arguments.html#accepting-command-line-arguments
    Accepting commandline arguments

  https://doc.rust-lang.org/book/ch12-04-testing-the-librarys-functionality.html
    Just moved some part of the code from src/main.rs to src/lib.rs.

  https://doc.rust-lang.org/book/ch12-05-working-with-environment-variables.html
    Environment variables

    Creating a test that tests ignore case
    Creating a search function that ignores case
    Creating an additional config value (boolean) for ignore_case

  https://doc.rust-lang.org/book/ch12-06-writing-to-stderr-instead-of-stdout.html
    Write errors to stderr (instead of stdout)
      almost identical to println, but with a leading "e"
      > eprintln!("some error :/")


https://doc.rust-lang.org/book/ch13-00-functional-features.html
  Functional Language Features: Iterators and Closures
    Covering:
      - Closures, a function-like construct you can store in a variable
      - Iterators, a way of processing a series of elements
      - How to use closures and iterators to improve project in Chapter 12
      - The performance of closures and iterators

  https://doc.rust-lang.org/book/ch13-01-closures.html
    closures:
      - anonymous functions you can put in a variable
      - the variable can be called or passed to another function
      - captures values from the scope in which they're defined

    The shortest possible closure definition:
      > let example_closure = |x| x;
    ..it just returns the value it is passed

    declaring closures with annotation (4 examples)
      > fn  add_one_v1   (x: u32) -> u32 { x + 1 }
      > let add_one_v2 = |x: u32| -> u32 { x + 1 };
      > let add_one_v3 = |x|             { x + 1 };
      > let add_one_v4 = |x|               x + 1  ;
    These will produce the same behavior when they're called.
    The add_one_v3 and add_one_v4 lines require the closures to be evaluated
    ..to be able to compile because the types will be inferred from their usage.

    https://doc.rust-lang.org/book/ch13-01-closures.html#capturing-references-or-moving-ownership
      closure will decide how to handle ownership for passed values
        - borrowing immutably
        - borrowing mutably
        - taking ownership
      ..based on what the body of the function does with the captured values

      example:
        > let list = vec![1, 2, 3];
        > let my_closure = || println!("From closure: {:?}", list);
        >
        > my_closure();                                 // println!() does noly need to borrow
        > println!("after calling closure {:?}", list); // that means the list is still available

    https://doc.rust-lang.org/book/ch13-01-closures.html#moving-captured-values-out-of-closures-and-the-fn-traits
      The way a closure captures and handles values from the environment affects which traits the closure implements.
      There are 3 traits, FnOnce, FnMut and Fn.
      Closures will automatically implement one, two, or all three of these Fn traits,
      depending on how the closure's body handles the values.
        FnOnce:
          Closure that moves captured values out of its body will only implement FnOnce
          These can only be called called once.
        FnMut:
          Might mutate the captured values, but does not move captured values out of their body.
        Fn:
          Dont move captured values out of their body.
          Dont mutate captured values.
          Captures nothing from their environment

  https://doc.rust-lang.org/book/ch13-02-iterators.html
    Iterators
      - All iterators implement a trait named Iterator (defined in the standard library).
      - The Iterator trait only requires implementors to define one method: the next method
      - The next method returns one item of the iterator at a time wrapped in Some.
      - The next method returns None When iteration is over.

      The definition of the iterator trait in the std lib looks like this:
        > pub trait Iterator {
        >     type Item;
        >     fn next(&mut self) -> Option<Self::Item>;
        > }

  https://doc.rust-lang.org/book/ch13-03-improving-our-io-project.html
    Improving our i/o project - minigrep
