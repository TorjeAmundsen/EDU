https://doc.rust-lang.org/book/ch01-01-installation.html

https://doc.rust-lang.org/book/ch01-02-hello-world.html

https://doc.rust-lang.org/book/ch01-03-hello-cargo.html
  Cargo - the build system and package manager
    It does multiple things:
      - building your code
      - downloading the libraries (dependencies)
      - checks code
      - runs the code

    create and run a new project
      $ cargo new <project_name>
        source files will live inside the <project_name>/src
      $ cd <project_name>
        cd into the project directory to run additional cargo commands
      $ cargo build
        creates build directory target/debug
        then compiles binary and places it in ./target/debug/<project_name>
      $ cargo build --release
        compile it with optimizations (faster execution)
        NOTE: creates an executable in target/release instead of target/debug
      $ cargo run
        same as cargo build, but also runs the binary if compile succeeded
        ..most developers use cargo run
      $ cargo check
        build a project without producing a binary to check for errors

    Crates
      packages of code are referred to as crates

    Cargo.lock
      Keeps track of the exact versions of dependencies in your project.
      We do not ever need to change this file manually.
      Cargo manages its contents for you.

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html
  $ cargo new guessing_game
  $ cd guessing_game

  Importing and "Prelude".
    Manually importing every single thing that you use is very verbose.
    Automatically importing a lot of things that a program never uses is bloat.
    A balance needs to be struck and that is the Prelude.
    The prelude is the list of things that Rust automatically imports into every Rust program.

    The use statement.
      Importing is don with "use".

  Importing standard io library (bringing the library into scope)
    > use std::io;
      this is used read input and writing output etc.

  Variables.
    > let mut <name> = <value>;

    immutable
      > let apples = 5;
    mutable
      > let mut bananas = 5;

  Types
    String: growable UTF-8 encoded bit of text

  Syntax
    :: Is an associated function of a type.
      > String::new();
        new is associated with the String type
        new creates a new, empty string..

    .name() Is a method
      > io::stdin()
      >   .read_line(&mut some_var)
        here the read_line() is a method on stdin()

    & Is a reference
      > .read_line(&mut some_var)
        referencing "some_var" Note: references are immutable

    io::stdin().read_line() returns a "Result" value which is an "enumeration" (enum)
      used to encode error-handling information with variants Ok and Err
      enums are covered in chapter 6..
      the "Result" value has an expect method
      if value is Err -> expect(argument) will cause the program to crash and display the message passed as argument
        most likely it would be OS related in this very case..

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#generating-a-secret-number
  Generate secret number using a "crate"
    ..a crate is a collection of Rust source code files
  
  $ cargo build
  Cargo.lock
    Rust creates the Cargo.lock file the first time you run cargo build.
    This will force the use of same version if new versions of dependency is released.
    This will reproduce builds identical to previous builds on unchanged source code.

  $ cargo update
    Ignore the Cargo.lock file and figure out all the latest versions in Cargo.toml.
    It will still not update to new "major" versions, only "minor" versions.
      see https://semver.org/

  $ cargo doc --open
    Automatically build documentation (HTML) provided for all dependencies
    It will open your default browser when done.
      If you are interested in other functionality in the rand crate,
      run cargo doc --open and click rand in the sidebar on the left.


https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html
  Common Programming Concepts
  
  Rust encourages immutability, and this is the standard for variables unless specified.
    can not change
      > let  x = 5;
    can change
      > let mut x = 5;
    can not change, ever (should always be written in upper case)
      const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
        the result is calculated at compile time so that on execution time it does not have to

  Shadowing (assign new value to immutable variable)
    Rust helps you avoid creating duplicate variables with unique names.
    Creating a new variable with same name as an existing one will "shadow" the old value with new.
    Shadows are scope related, an inner scope does not shadow a variable from an outer scope.
    When shadowing, the variable might also change type, not only value.


https://doc.rust-lang.org/book/ch03-02-data-types.html
  Data Types

  Type anotation
    specify type when declaring variables (sometimes required like in the line below)
    > let guess: u32 = "42".parse().expect("Not a number!");
      it is the value after :, in this case the anotation is "u32"

  Integers (integer types default to i32 if not specified)
    Length    Signed  Unsigned
    8-bit	    i8  	  u8
    16-bit	  i16     u16
    32-bit    i32     u32
    64-bit    i64     u64
    128-bit   i128    u128
    arch      isize   usize
      ..each variant can be either signed (can be negative) or unsigned (only positive)

      ..integer overflow (complement wrapping)
        Variable starts from 0 and adds overflow value.
        https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-overflow

  Floating points
    f32 is a 32 bit value with single-precision
    f64 is a 64 bit value with double precision


https://doc.rust-lang.org/book/ch03-03-how-functions-work.html
  Functions
