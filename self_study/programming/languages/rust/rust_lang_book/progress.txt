https://doc.rust-lang.org/book/ch01-01-installation.html

https://doc.rust-lang.org/book/ch01-02-hello-world.html

https://doc.rust-lang.org/book/ch01-03-hello-cargo.html
  Cargo - the build system and package manager
    It does multiple things:
      - building your code
      - downloading the libraries (dependencies)
      - checks code
      - runs the code

    create and run a new project
      $ cargo new <project_name>
        source files will live inside the <project_name>/src
      $ cd <project_name>
        cd into the project directory to run additional cargo commands
      $ cargo build
        creates build directory target/debug
        then compiles binary and places it in ./target/debug/<project_name>
      $ cargo build --release
        compile it with optimizations (faster execution)
        NOTE: creates an executable in target/release instead of target/debug
      $ cargo run
        same as cargo build, but also runs the binary if compile succeeded
        ..most developers use cargo run
      $ cargo check
        build a project without producing a binary to check for errors

    Crates
      packages of code are referred to as crates

    Cargo.lock
      Keeps track of the exact versions of dependencies in your project.
      We do not ever need to change this file manually.
      Cargo manages its contents for you.

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html
  $ cargo new guessing_game
  $ cd guessing_game

  Importing and "Prelude".
    Manually importing every single thing that you use is very verbose.
    Automatically importing a lot of things that a program never uses is bloat.
    A balance needs to be struck and that is the Prelude.
    The prelude is the list of things that Rust automatically imports into every Rust program.

    The use statement.
      Importing is don with "use".

  Importing standard io library (bringing the library into scope)
    > use std::io;
      this is used read input and writing output etc.

  Variables.
    > let mut <name> = <value>;

    immutable
      > let apples = 5;
    mutable
      > let mut bananas = 5;

  Types
    String: growable UTF-8 encoded bit of text

  Syntax
    :: Is an associated function of a type.
      > String::new();
        new is associated with the String type
        new creates a new, empty string..

    .name() Is a method
      > io::stdin()
      >   .read_line(&mut some_var)
        here the read_line() is a method on stdin()

    & Is a reference
      > .read_line(&mut some_var)
        referencing "some_var" Note: references are immutable

    io::stdin().read_line() returns a "Result" value which is an "enumeration" (enum)
      used to encode error-handling information with variants Ok and Err
      enums are covered in chapter 6..
      the "Result" value has an expect method
      if value is Err -> expect(argument) will cause the program to crash and display the message passed as argument
        most likely it would be OS related in this very case..

https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html#generating-a-secret-number
  Generate secret number using a "crate"
    ..a crate is a collection of Rust source code files
  
  $ cargo build
  Cargo.lock
    Rust creates the Cargo.lock file the first time you run cargo build.
    This will force the use of same version if new versions of dependency is released.
    This will reproduce builds identical to previous builds on unchanged source code.

  $ cargo update
    Ignore the Cargo.lock file and figure out all the latest versions in Cargo.toml.
    It will still not update to new "major" versions, only "minor" versions.
      see https://semver.org/

  $ cargo doc --open
    Automatically build documentation (HTML) provided for all dependencies
    It will open your default browser when done.
      If you are interested in other functionality in the rand crate,
      run cargo doc --open and click rand in the sidebar on the left.


https://doc.rust-lang.org/book/ch03-00-common-programming-concepts.html
  Common Programming Concepts
  
  Rust encourages immutability, and this is the standard for variables unless specified.
    can not change
      > let  x = 5;
    can change
      > let mut x = 5;
    can not change, ever (should always be written in upper case)
      const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;
        the result is calculated at compile time so that on execution time it does not have to

  Shadowing (assign new value to immutable variable)
    Rust helps you avoid creating duplicate variables with unique names.
    Creating a new variable with same name as an existing one will "shadow" the old value with new.
    Shadows are scope related, an inner scope does not shadow a variable from an outer scope.
    When shadowing, the variable might also change type, not only value.


https://doc.rust-lang.org/book/ch03-02-data-types.html
  Data Types

  Type anotation
    specify type when declaring variables (sometimes required like in the line below)
    > let guess: u32 = "42".parse().expect("Not a number!");
      it is the value after :, in this case the anotation is "u32"

  Integers (integer types default to i32 if not specified)
    Length    Signed  Unsigned
    8-bit	    i8  	  u8
    16-bit	  i16     u16
    32-bit    i32     u32
    64-bit    i64     u64
    128-bit   i128    u128
    arch      isize   usize
      ..each variant can be either signed (can be negative) or unsigned (only positive)

      ..integer overflow (complement wrapping)
        Variable starts from 0 and adds overflow value.
        https://doc.rust-lang.org/book/ch03-02-data-types.html#integer-overflow

  Floating points
    f32 is a 32 bit value with single-precision
    f64 is a 64 bit value with double precision


https://doc.rust-lang.org/book/ch03-03-how-functions-work.html
  Functions

https://doc.rust-lang.org/book/ch03-05-control-flow.html
  Control flow

https://doc.rust-lang.org/book/ch04-00-understanding-ownership.html
  Ownership - memory handling in Rust

    The Stack and the Heap
      Both are parts of memory, but are structured in different ways.
      Stack (stack based -> fast)
        Stores values in the order it gets them and removes the values in the opposite order.
          ..last in, first out e.g. push -> add and pop -> remove.
      Heap (allocation/pointer based -> slower)
        Is less organized: when you put data on the heap, you request a certain amount of memory space.
        The memory allocator finds an empty spot in the heap that is big enough, mark it as being used.
        It returns a pointer (the memory address of the location).
          ..this is called "allocating on the heap"
      When program calls a function,
        the values passed into the function
        and the functions local variables
        ..get pushed onto the stack.
      When the function is over,
        ..those values get popped off the stack.

  Following the ownership, the goal is to minimize the data stored as heap by..
    ..keep track of what parts of code are using data on the heap
    ..minimize the amount of data (especially duplicate) on the heap
    ..and cleaning up unused data on the heap,

  Ownership rules
    Each value has an owner.
    Only one owner at a time.
    When owner goes out of scope, value is dropped.

  Illustrating the ownership: https://doc.rust-lang.org/book/ch04-01-what-is-ownership.html#the-string-type

https://doc.rust-lang.org/book/ch04-02-references-and-borrowing.html#references-and-borrowing


https://doc.rust-lang.org/book/ch04-03-slices.html
  The Slice Type
    ..slices let you reference a contiguous sequence of elements in a collection
    ..rather than the whole collection.

  A string slice is a reference to part of a String
    > let s = String::from("hello world");
    > let hello = &s[0..5];
    > let world = &s[6..11];


https://doc.rust-lang.org/book/ch05-00-structs.html
  Structs

  Each struct you define is its own type.
  A function that takes a parameter of type Color cannot take a Point as an argument,
  even though both types are made up of the same primitive datatypes e.g. i32.

  https://doc.rust-lang.org/book/ch05-02-example-structs.html

  https://doc.rust-lang.org/book/ch05-02-example-structs.html#adding-useful-functionality-with-derived-traits

  https://doc.rust-lang.org/book/ch05-03-method-syntax.html

  Declaring structs:
    > struct Rectangle {
    >   width: u32,
    >   height: u32,
    > }

  Implement methods to the struct:
    > impl Rectangle {
    >   fn area(&self) -> u32 {
    >     self.width * self.height
    >   }
    > }

  Instantiate struct:
    > let rect = Rectangle {
    >   width: 30,
    >   height: 50,
    > };

  Call method on struct object:
    > rect.area();
